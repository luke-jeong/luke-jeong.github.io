---
layout: post
title:  "[Spring] Spring Basic 11"
date:   2023-03-18 23:35:00 +0900
categories: Spring
---
## 싱글톤 빈과 함께 사용시 문제점

* 스프링 컨테이너에 프로토타입 빈 직접 요청1
1. 클라이언트A는 스프링 컨테이너에 프로토타입 빈을 요청한다.
2. 스프링 컨테이너는 프로토타입 빈을 새로 생성해서 반환(x01)한다. 해당 빈의 count 필드 값은 0이다.
3. 클라이언트는 조회한 프로토타입 빈에 addCount() 를 호출하면서 count 필드를 +1 한다.  
   결과적으로 프로토타입 빈(x01)의 count는 1이 된다
* 스프링 컨테이너에 프로토타입 빈 직접 요청2
4. 클라이언트B는 스프링 컨테이너에 프로토타입 빈을 요청한다.
5. 스프링 컨테이너는 프로토타입 빈을 새로 생성해서 반환(x02)한다. 해당 빈의 count 필드 값은 0이다.
6. 클라이언트는 조회한 프로토타입 빈에 addCount() 를 호출하면서 count 필드를 +1 한다.
   결과적으로 프로토타입 빈(x02)의 count는 1이 된다.
> 서로 다른 클라이언트가 호출하면 addCount 값은 유지되지 않고 새로 생성되므로 1이 된다.
---
* 싱글톤에서 프로토타입 빈 사용1  
  clientBean 은 싱글톤이므로, 보통 스프링 컨테이너 생성 시점에 함께 생성되고, 의존관계 주입도 발생한다.
1. clientBean 은 의존관계 자동 주입을 사용한다. 주입 시점에 스프링 컨테이너에 프로토타입 빈을 요청한다.
2. 스프링 컨테이너는 프로토타입 빈을 생성해서 clientBean 에 반환한다. 프로토타입 빈의 count 필드 값은 0이다.  
   이제 clientBean 은 프로토타입 빈을 내부 필드에 보관한다. (정확히는 참조값을 보관한다.)
* 싱글톤에서 프로토타입 빈 사용2  
  클라이언트 A는 clientBean 을 스프링 컨테이너에 요청해서 받는다.싱글톤이므로 항상 같은 clientBean 이 반환된다.
3. 클라이언트 A는 clientBean.logic() 을 호출한다.
4. clientBean 은 prototypeBean의 addCount() 를 호출해서 프로토타입 빈의 count를 증가한다.
   count값이 1이 된다
* 싱글톤에서 프로토타입 빈 사용3  
  클라이언트 B는 clientBean 을 스프링 컨테이너에 요청해서 받는다.싱글톤이므로 항상 같은 clientBean 이 반환된다.  
  **여기서 중요한 점이 있는데, clientBean이 내부에 가지고 있는 프로토타입 빈은 이미 과거에 주입이 끝난 빈이다. 주입 시점에 스프링 컨테이너에 요청해서 프로토타입 빈이 새로 생성이 된 것이지, 사용 할 때마다 새로 생성되는 것이 아니다!**
5. 클라이언트 B는 clientBean.logic() 을 호출한다.
6. clientBean 은 prototypeBean의 addCount() 를 호출해서 프로토타입 빈의 count를 증가한다. 원래 count 값이 1이었으므로 2가 된다.
> 서로 다른 클라이언트가 호출했음에도 addCount 값이 유지되지 되어 기존 값에서 +1이 된다.